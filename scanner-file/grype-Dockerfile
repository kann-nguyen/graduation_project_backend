# Use the latest LTS version of Node.js as the base image
FROM node:lts

# Set the working directory in the container
WORKDIR /app

# Run the tool installation command
RUN curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin

# Clone the code repository
RUN git clone https://github.com/kann-nguyen/scanner-template-1.git .

ADD . ./

RUN npm install

# Replace content in index.js
RUN sed -i 's@<code_placeholder>@async function processImageScan(name) {\n  const uuid = randomUUID();\n  log(\`[SCAN-START] Received scan request for image: \${name} (UUID: \${uuid})\`);\n  \n  try {\n    log(\`[SCAN-SETUP] Creating scan directory for image: \${name}\`);\n    await mkdir(\"./scan-log\", { recursive: true });\n    const outputPath = \`./scan-log/\${uuid}.json\`;\n    log(\`[SCAN-SETUP] Output file will be: \${outputPath}\`);\n    \n    log(\`[SCAN-PROCESS] Starting Trivy scan for image: \${name}...\`);\n    await new Promise((resolve, reject) => {\n      const trivyArgs = [\n        \"image\",\n        \`\${name}\`,\n        \"--scanners\", \"vuln\",\n        \"--format\", \"json\",\n        \"--output\", outputPath\n      ];\n      log(\`[SCAN-COMMAND] Running: trivy \${trivyArgs.join(\" \")}\`);\n      \n      const command = spawn(\"trivy\", trivyArgs);\n      \n      command.stdout.on(\"data\", (data) => {\n        const output = data.toString().trim();\n        if (output) {\n          log(\`[SCAN-OUTPUT] Trivy: \${output}\`);\n        }\n      });\n      \n      command.stderr.on(\"data\", (data) => {\n        const error = data.toString().trim();\n        if (error) {\n          log(\`[SCAN-ERROR] Trivy Error: \${error}\`, \"ERROR\");\n        }\n      });\n      \n      command.on(\"close\", (code) => {\n        log(\`[SCAN-COMPLETE] Trivy process exited with code \${code}\`);\n        if (code === 0) {\n          resolve();\n        } else {\n          reject(new Error(\`Trivy exited with code \${code}\`));\n        }\n      });\n    });\n    \n    log(\`[SCAN-PROCESSING] Reading scan results from \${outputPath}\`);\n    const data = await readFile(outputPath, \"utf8\");\n    log(\`[SCAN-DATA] File size: \${data.length} bytes\`);\n    \n    log(\`[SCAN-PARSING] Parsing JSON results\`);\n    const json = JSON.parse(data);\n    let vulnerabilities = [];\n    \n    if (json.Results) {\n      log(\`[SCAN-RESULTS] Found \${json.Results.length} result groups\`);\n      for (const result of json.Results) {\n        log(\`[SCAN-RESULTS] Processing result for target: \${result.Target || \'unknown\'}\`);\n        if (result.Vulnerabilities) {\n          log(\`[SCAN-VULNERABILITIES] Found \${result.Vulnerabilities.length} vulnerabilities for target: \${result.Target || \'unknown\'}\`);\n          const vulns = await Promise.all(result.Vulnerabilities.map(async (vuln) => {\n            log(\`[SCAN-VULNERABILITY] Processing: \${vuln.VulnerabilityID} (Severity: \${vuln.Severity})\`);\n            const vulnerability = {\n              id: vuln.VulnerabilityID,\n              severity: vuln.Severity,\n              description: vuln.Description,\n              cvss: vuln.CVSS ? [\n                {\n                  metrics: {\n                    baseScore: vuln.CVSS?.nvd?.V3Score || null\n                  },\n                  vector: vuln.CVSS?.nvd?.V3Vector || null\n                }\n              ] : [],\n              cwe: vuln.CweIDs || []\n            };\n            \n            return processVulnerability(vulnerability);\n          }));\n          \n          log(\`[SCAN-PROCESSING] Added \${vulns.length} processed vulnerabilities\`);\n          vulnerabilities = [...vulnerabilities, ...vulns];\n        } else {\n          log(\`[SCAN-RESULTS] No vulnerabilities found for target: \${result.Target || \'unknown\'}\`);\n        }\n      }\n    } else {\n      log(\`[SCAN-RESULTS] No results found in the scan output\`);\n    }    \n    log(\`[SCAN-STATS] Generating vulnerability statistics\`);\n    getVulnerabilityStats(vulnerabilities);\n    \n    log(\`[SCAN-SECURITY] Determining security state for \${vulnerabilities.length} vulnerabilities\`);\n    const securityState = determineSecurityState(vulnerabilities);\n    log(\`[SCAN-SECURITY] Security state determined: \${securityState}\`);\n    \n    log(\`[SCAN-CLEANUP] Removing temporary scan file: \${outputPath}\`);\n    await unlink(outputPath);\n    \n    const payload = {\n      eventCode: \"IMAGE_SCAN_COMPLETE\",\n      imageName: name,\n      securityState,\n      data: vulnerabilities\n    };\n    \n    log(\`[SCAN-WEBHOOK] Preparing to send \${vulnerabilities.length} vulnerabilities to \${process.env.API_URL}/webhook/image\`);\n    log(\`[SCAN-WEBHOOK] Sending scan results to \${process.env.API_URL}/webhook/image\`);\n    \n    try {\n      log(\`[SCAN-DEBUG] Webhook payload size: \${JSON.stringify(payload).length} bytes\`);\n      const response = await axios.post(\`\${process.env.API_URL}/webhook/image\`, payload);\n      log(\`[SCAN-WEBHOOK] Webhook response status: \${response.status}\`);\n    } catch (webhookError) {\n      log(\`[SCAN-WEBHOOK] Error sending webhook: \${webhookError.message}\`, \"ERROR\");\n      if (webhookError.response) {\n        log(\`[SCAN-WEBHOOK] Response status: \${webhookError.response.status}\`, \"ERROR\");\n      }\n    }\n    \n    log(\`[SCAN-COMPLETE] Scan completed successfully for image: \${name} (UUID: \${uuid})\`);\n    return { success: true, requestId: uuid };\n  } catch (error) {\n    log(\`[SCAN-ERROR] Error during image scan: \${error.message}\`, \"ERROR\");\n    \n    // Log more detailed error information if available\n    if (error.stack) {\n      log(\`[SCAN-ERROR] Stack trace: \${error.stack}\`, \"ERROR\");\n    }\n    \n    return { success: false, error: error.message, requestId: uuid };\n  }\n}@' index.js

# Install Prettier to format the code
RUN npm install -g prettier

# Format the code
RUN prettier --write .

EXPOSE 3000

# Start the server when the container is run
CMD [ "npm", "start" ]