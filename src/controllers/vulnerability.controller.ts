import { isDocumentArray } from "@typegoose/typegoose";
import { Request, Response } from "express";
import {
  ChangeHistoryModel,
  ProjectModel,
  ResolutionHistoryModel,
  TicketModel,
} from "../models/models";
import { errorResponse, successResponse } from "../utils/responseFormat";
import { fetchVulnsFromNVD } from "../utils/vuln";

/**
 * Lấy tiến độ xử lý các lỗ hổng trong dự án
 * @param {Request} req - Request từ client, chứa tên dự án trong query
 * @param {Response} res - Response chứa tổng số lỗ hổng và số lượng đã được xử lý
 * @returns {Promise<Response>} - Trả về JSON response
 */
export async function getResolveProgress(req: Request, res: Response) {
  const { projectName } = req.query;
  try {
    const tickets = await TicketModel.find({ projectName });
    const resolvedTickets = tickets.filter(
      (ticket) => ticket.status === "closed"
    );
    
    // Đếm số lượng lỗ hổng đã được xử lý
    let count = 0;
    resolvedTickets.forEach(
      (ticket) => (count += ticket.targetedVulnerability.length)
    );
    
    const project = await ProjectModel.findOne({ name: projectName }).populate({
      path: "phaseList",
      populate: {
        path: "artifacts",
      },
    });
    
    if (!project) {
      return res.json(errorResponse("Project does not exist"));
    }
    
    let total = 0;
    if (isDocumentArray(project.phaseList)) {
      project.phaseList.forEach((phase) => {
        if (isDocumentArray(phase.artifacts)) {
          phase.artifacts.forEach((artifact) => {
            total += artifact?.vulnerabilityList
              ? artifact.vulnerabilityList.length
              : 0;
          });
        }
      });
    }
    
    const response = {
      total,
      resolved: count,
    };
    return res.json(successResponse(response, "Progress fetched successfully"));
  } catch (error) {
    return res.json(errorResponse(`Internal server error: ${error}`));
  }
}

/**
 * Thêm một bản ghi giải pháp cho lỗ hổng bảo mật
 * @param {Request} req - Request từ client, chứa thông tin lỗ hổng và giải pháp trong body
 * @param {Response} res - Response xác nhận thêm thành công hoặc lỗi
 * @returns {Promise<Response>} - Trả về JSON response
 */
export async function addResolution(req: Request, res: Response) {
  const { data } = req.body;
  try {
    const resolution = await ResolutionHistoryModel.findOne({
      cveId: data.cveId,
    });
    if (!resolution) {
      await ResolutionHistoryModel.create({
        cveId: data.cveId,
        resolution: [
          {
            createdBy: req.user?.username,
            description: data.description,
          },
        ],
      });
    } else {
      await ResolutionHistoryModel.updateOne(
        { cveId: data.cveId },
        {
          $push: {
            resolution: {
              createdBy: req.user?.username,
              description: data.description,
            },
          },
        }
      );
    }
    
    const tickets = await TicketModel.find({
      targetedVulnerability: {
        $elemMatch: {
          cveId: data.cveId,
        },
      },
    });
    
    tickets.forEach(async (ticket) => {
      await ChangeHistoryModel.create({
        objectId: ticket._id,
        action: "update",
        timestamp: new Date(),
        account: req.user?._id,
        description: `${req.user?.username} added a resolution to ${data.cveId}`,
      });
    });
    
    return res.json(successResponse(null, "Resolution added successfully"));
  } catch (error) {
    return res.json(errorResponse(`Internal server error: ${error}`));
  }
}

/**
 * Lấy danh sách các giải pháp cho một lỗ hổng bảo mật
 * @param {Request} req - Request từ client, chứa cveId trong query
 * @param {Response} res - Response chứa danh sách giải pháp hoặc lỗi
 * @returns {Promise<Response>} - Trả về JSON response
 */
export async function getResolution(req: Request, res: Response) {
  const { cveId } = req.query;
  try {
    const resolution = await ResolutionHistoryModel.find({ cveId });
    if (!resolution) {
      return res.json(errorResponse("Resolution not found"));
    }
    return res.json(
      successResponse(resolution, "Resolution fetched successfully")
    );
  } catch (error) {
    return res.json(errorResponse(`Internal server error: ${error}`));
  }
}

/**
 * Phê duyệt một giải pháp đã được đề xuất
 * @param {Request} req - Request từ client, chứa resolutionId trong body
 * @param {Response} res - Response xác nhận phê duyệt thành công hoặc lỗi
 * @returns {Promise<Response>} - Trả về JSON response
 */
export async function approveResolution(req: Request, res: Response) {
  const {
    data: { resolutionId },
  } = req.body;
  try {
    await ResolutionHistoryModel.findOneAndUpdate(
      {
        resolution: {
          $elemMatch: {
            _id: resolutionId,
          },
        },
      },
      {
        $set: {
          "resolution.$.isApproved": true,
        },
      }
    );
    
    const resolution = await ResolutionHistoryModel.findOne({
      resolution: {
        $elemMatch: {
          _id: resolutionId,
        },
      },
    });
    const cveId = resolution?.cveId;
    
    const tickets = await TicketModel.find({
      targetedVulnerability: {
        $elemMatch: {
          cveId: cveId,
        },
      },
    });
    
    tickets.forEach(async (ticket) => {
      await ChangeHistoryModel.create({
        objectId: ticket._id,
        action: "update",
        timestamp: new Date(),
        account: req.user?._id,
        description: `${req.user?.username} approved a resolution of ${cveId}`,
      });
    });
    
    return res.json(successResponse(null, "Resolution approved successfully"));
  } catch (error) {
    return res.json(errorResponse(`Internal server error: ${error}`));
  }
}
